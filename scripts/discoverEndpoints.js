import fs from 'fs';
import path from 'path';

const backendApiDir = path.resolve(process.cwd(), 'backend/src/api');

// parse imports in backend/src/api/index.js to map variable -> domain folder
const rootIndex = fs.readFileSync(path.join(backendApiDir, 'index.js'), 'utf-8');
const importRegex = /import\s+(\w+)\s+from\s+"\.\/([^\/]+)\/index.js"/g;
const varToDomain = {};
let m;
while ((m = importRegex.exec(rootIndex)) !== null) {
  varToDomain[m[1]] = m[2];
}

// parse r.use lines to get prefix per domain
const prefixRegex = /r\.use\((?:"([^"]+)",\s*)?(\w+)\)/g;
const domainPrefixes = {};
while ((m = prefixRegex.exec(rootIndex)) !== null) {
  const prefix = m[1] || '';
  const varName = m[2];
  const domain = varToDomain[varName];
  if (domain) {
    domainPrefixes[domain] = prefix;
  }
}

function parseValidators(validatorFile) {
  const content = fs.readFileSync(validatorFile, 'utf-8');
  const blockRegex = /export const (\w+) = \[([\s\S]*?)\];/g;
  const validators = {};
  let block;
  while ((block = blockRegex.exec(content)) !== null) {
    const name = block[1];
    const bodyFields = Array.from(block[2].matchAll(/body\("([^"]+)"\)/g)).map(x => x[1]);
    const paramFields = Array.from(block[2].matchAll(/param\("([^"]+)"\)/g)).map(x => x[1]);
    const queryFields = Array.from(block[2].matchAll(/query\("([^"]+)"\)/g)).map(x => x[1]);
    validators[name] = { body: bodyFields, params: paramFields, query: queryFields };
  }
  return validators;
}

const endpointMap = {};

for (const domain of fs.readdirSync(backendApiDir)) {
  const domainPath = path.join(backendApiDir, domain);
  if (!fs.statSync(domainPath).isDirectory()) continue;
  if (domain === '_test') continue;
  const prefix = domainPrefixes[domain] || '';
  const indexFile = path.join(domainPath, 'index.js');
  if (!fs.existsSync(indexFile)) continue;
  const validatorFile = path.join(domainPath, 'validator.js');
  const validators = fs.existsSync(validatorFile) ? parseValidators(validatorFile) : {};
  const indexContent = fs.readFileSync(indexFile, 'utf-8');
  const routeRegex = /r\.(get|post|put|patch|delete)\(\s*"([^"]+)"\s*,([\s\S]*?)\);/g;
  let routeMatch;
  const domainEndpoints = [];
  while ((routeMatch = routeRegex.exec(indexContent)) !== null) {
    const method = routeMatch[1].toUpperCase();
    const subPath = routeMatch[2];
    const argsStr = routeMatch[3];
    const args = argsStr.split(',').map(a => a.trim()).filter(Boolean);
    const handler = args[args.length - 1];
    const name = handler.split('.').pop();
    const validatorNames = args.filter(a => validators[a]);
    let pathFull;
    if (subPath === '/') pathFull = prefix || '/';
    else pathFull = `${prefix}${subPath}` || subPath;
    domainEndpoints.push({ name, method, path: pathFull, validators: validatorNames.map(v=>validators[v]), auth: args.some(a=>a.startsWith('auth')) });
  }
  if (domainEndpoints.length) endpointMap[domain] = domainEndpoints;
}

const outLines = [];
outLines.push('// auto-generated by scripts/discoverEndpoints.js');
outLines.push('export const endpoints = ' + JSON.stringify(endpointMap, null, 2) + '\n');
fs.mkdirSync(path.resolve('frontend/src/lib/api'), { recursive: true });
fs.writeFileSync(path.resolve('frontend/src/lib/api/endpoints.ts'), outLines.join('\n'));
console.log('Generated endpoints.ts');
